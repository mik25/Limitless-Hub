"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NsisUpdater = undefined;

var _bluebirdLstC;

function _load_bluebirdLstC() {
    return _bluebirdLstC = require("bluebird-lst-c");
}

var _child_process;

function _load_child_process() {
    return _child_process = require("child_process");
}

var _path = _interopRequireWildcard(require("path"));

var _os;

function _load_os() {
    return _os = require("os");
}

var _electronBuilderHttp;

function _load_electronBuilderHttp() {
    return _electronBuilderHttp = require("electron-builder-http");
}

var _api;

function _load_api() {
    return _api = require("./api");
}

var _fsExtraP;

function _load_fsExtraP() {
    return _fsExtraP = require("fs-extra-p");
}

require("source-map-support/register");

var _AppUpdater;

function _load_AppUpdater() {
    return _AppUpdater = require("./AppUpdater");
}

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

class NsisUpdater extends (_AppUpdater || _load_AppUpdater()).AppUpdater {
    constructor(options) {
        super(options);
        this.quitAndInstallCalled = false;
        this.quitHandlerAdded = false;
    }
    /**
     * Start downloading update manually. You can use this method if `autoDownload` option is set to `false`.
     * @returns {Promise<string>} Path to downloaded file.
     */
    doDownloadUpdate(versionInfo, fileInfo) {
        var _this = this;

        return (0, (_bluebirdLstC || _load_bluebirdLstC()).coroutine)(function* () {
            const downloadOptions = {
                skipDirCreation: true
            };
            if (_this.listenerCount((_api || _load_api()).DOWNLOAD_PROGRESS) > 0) {
                downloadOptions.onProgress = function (it) {
                    return _this.emit((_api || _load_api()).DOWNLOAD_PROGRESS, it);
                };
            }
            if (fileInfo != null && fileInfo.sha2 != null) {
                downloadOptions.sha2 = fileInfo.sha2;
            }
            return (0, (_fsExtraP || _load_fsExtraP()).mkdtemp)(`${ _path.join((0, (_os || _load_os()).tmpdir)(), "up") }-`).then(function (it) {
                return (0, (_electronBuilderHttp || _load_electronBuilderHttp()).download)(fileInfo.url, _path.join(it, fileInfo.name), downloadOptions);
            }).then(function (it) {
                _this.setupPath = it;
                _this.addQuitHandler();
                const version = _this.versionInfo.version;
                if (_this.logger != null) {
                    _this.logger.info(`New version ${ version } has been downloaded`);
                }
                _this.emit("update-downloaded", _this.versionInfo, null, version, null, null, function () {
                    _this.quitAndInstall();
                });
                return it;
            }).catch(function (e) {
                _this.emit("error", e, (e.stack || e).toString());
                throw e;
            });
        })();
    }
    addQuitHandler() {
        if (this.quitHandlerAdded) {
            return;
        }
        this.quitHandlerAdded = true;
        this.app.on("quit", () => {
            this.install(true);
        });
    }
    quitAndInstall() {
        if (this.install(false)) {
            this.app.quit();
        }
    }
    install(isSilent) {
        if (this.quitAndInstallCalled) {
            return false;
        }
        const setupPath = this.setupPath;
        if (!this.updateAvailable || setupPath == null) {
            const message = "No update available, can't quit and install";
            this.emit("error", new Error(message), message);
            return false;
        }
        // prevent calling several times
        this.quitAndInstallCalled = true;
        const args = ["--updated"];
        if (isSilent) {
            args.push("/S");
        }
        (0, (_child_process || _load_child_process()).spawn)(setupPath, args, {
            detached: true,
            stdio: "ignore"
        }).unref();
        return true;
    }
}
exports.NsisUpdater = NsisUpdater; //# sourceMappingURL=NsisUpdater.js.map