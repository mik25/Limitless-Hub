{
  "version": 3,
  "file": "electronHttpExecutor.js",
  "sourceRoot": "",
  "sources": [
    "../src/electronHttpExecutor.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "import { Socket } from \"net\"\nimport { net } from \"electron\"\nimport { ensureDir } from \"fs-extra-p\"\nimport BluebirdPromise from \"bluebird-lst-c\"\nimport * as path from \"path\"\nimport { HttpExecutor, DownloadOptions, maxRedirects, safeGetHeader, configurePipes, debug } from \"electron-builder-http\"\nimport { parse as parseUrl } from \"url\"\n\nexport class ElectronHttpExecutor extends HttpExecutor<Electron.RequestOptions, Electron.ClientRequest> {\n  async download(url: string, destination: string, options?: DownloadOptions | null): Promise<string> {\n    if (options == null || !options.skipDirCreation) {\n      await ensureDir(path.dirname(destination))\n    }\n\n    return await new BluebirdPromise<string>((resolve, reject) => {\n      this.doDownload(url, destination, 0, options || {}, (error: Error) => {\n        if (error == null) {\n          resolve(destination)\n        }\n        else {\n          reject(error)\n        }\n      })\n    })\n  }\n\n  private addTimeOutHandler(request: Electron.ClientRequest, callback: (error: Error) => void) {\n    request.on(\"socket\", function (socket: Socket) {\n      socket.setTimeout(60 * 1000, () => {\n        callback(new Error(\"Request timed out\"))\n        request.abort()\n      })\n    })\n  }\n\n  private doDownload(url: string, destination: string, redirectCount: number, options: DownloadOptions, callback: (error: Error | null) => void) {\n    const parsedUrl = parseUrl(url)\n    // user-agent must be specified, otherwise some host can return 401 unauthorised\n\n    const requestOpts = {\n      protocol: parsedUrl.protocol,\n      hostname: parsedUrl.hostname,\n      path: parsedUrl.path,\n      headers: {\n        \"User-Agent\": \"electron-builder\"\n      },\n    }\n\n    const request = net.request(requestOpts, (response: Electron.IncomingMessage) => {\n      if (response.statusCode >= 400) {\n        callback(new Error(`Cannot download \"${url}\", status ${response.statusCode}: ${response.statusMessage}`))\n        return\n      }\n\n      const redirectUrl = safeGetHeader(response, \"location\")\n      if (redirectUrl != null) {\n        if (redirectCount < maxRedirects) {\n          this.doDownload(redirectUrl, destination, redirectCount++, options, callback)\n        }\n        else {\n          callback(new Error(`Too many redirects (> ${maxRedirects})`))\n        }\n        return\n      }\n\n      configurePipes(options, response, destination, callback)\n    })\n    this.addTimeOutHandler(request, callback)\n    request.on(\"error\", callback)\n    request.end()\n  }\n\n  doApiRequest<T>(options: Electron.RequestOptions, token: string | null, requestProcessor: (request: Electron.ClientRequest, reject: (error: Error) => void) => void, redirectCount: number = 0): Promise<T> {\n    const requestOptions: any = options\n    if (debug.enabled) {\n      debug(`request: ${JSON.stringify(requestOptions, null, 2)}`)\n    }\n\n    if (token != null) {\n      (<any>requestOptions.headers).authorization = token.startsWith(\"Basic\") ? token : `token ${token}`\n    }\n\n    requestOptions.protocol = \"https:\"\n    return new BluebirdPromise<T>((resolve, reject, onCancel) => {\n      const request = net.request(options, response => {\n        try {\n          this.handleResponse(response, options, resolve, reject, redirectCount, token, requestProcessor)\n        }\n        catch (e) {\n          reject(e)\n        }\n      })\n      this.addTimeOutHandler(request, reject)\n      request.on(\"error\", reject)\n      requestProcessor(request, reject)\n      onCancel!(() => request.abort())\n    })\n  }\n}"
  ]
}
